import os
import json
import google.generativeai as genai
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Optional, Dict, Any, List
from dataclasses import asdict
from engine import (
    create_exercise_library, 
    weekly_plan, 
    export_program_to_text
)
from database import init_db, save_program_to_db, get_latest_program, delete_workout

# Configure the Gemini API
# Make sure to set the GOOGLE_API_KEY environment variable
api_key = os.getenv("GEMINI_API_KEY")
if not api_key:
    raise ValueError("GOOGLE_API_KEY environment variable not set")
genai.configure(api_key=api_key)
model = genai.GenerativeModel('gemini-2.0-flash')

app = FastAPI()

# Initialize Database
@app.on_event("startup")
async def startup_event():
    init_db()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class ChatRequest(BaseModel):
    message: str
    state: Optional[Dict[str, Any]] = None

class SavePlanRequest(BaseModel):
    plan_data: List[Dict[str, Any]]
    program_name: str = "My Squad Plan"
    description: Optional[str] = "Generated by AI"

@app.post("/save-plan")
async def save_plan(request: SavePlanRequest):
    try:
        program_id = save_program_to_db(request.program_name, request.description, request.plan_data)
        return {"status": "success", "program_id": program_id}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/active-program")
async def get_active_program():
    try:
        program = get_latest_program()
        return program
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.delete("/workout/{workout_id}")
async def delete_workout_endpoint(workout_id: int):
    try:
        delete_workout(workout_id)
        return {"status": "success"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

class UpdateWorkoutRequest(BaseModel):
    components: List[Dict[str, Any]]

@app.put("/workout/{workout_id}")
async def update_workout_endpoint(workout_id: int, request: UpdateWorkoutRequest):
    try:
        from database import update_workout_components
        update_workout_components(workout_id, request.components)
        return {"status": "success"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.delete("/program/{program_id}")
async def delete_program_endpoint(program_id: int):
    try:
        from database import delete_program
        delete_program(program_id)
        return {"status": "success"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

class ChatResponse(BaseModel):
    message: str
    state: Dict[str, Any]
    is_complete: bool = False
    plan: Optional[str] = None
    plan_data: Optional[List[Dict[str, Any]]] = None

class AdaptPlanRequest(BaseModel):
    current_plan: Dict[str, Any]
    user_request: str

@app.post("/adapt-plan")
async def adapt_plan(request: AdaptPlanRequest):
    prompt = f"""
You are an AI fitness assistant. Your task is to modify a JSON workout plan based on a user's request.
The user's request is: "{request.user_request}"

Here is the current workout plan in JSON format:
{json.dumps(request.current_plan, indent=2)}

Your instructions are:
1.  Read the user's request and the JSON data carefully.
2.  Modify the JSON data to fulfill the user's request.
3.  **You must return the complete, entire, updated JSON object.** Do not return only the changed parts.
4.  The structure of the JSON object must remain exactly the same as the original. Do not add, remove, or rename any keys at the top level of the JSON structure unless the user explicitly asks for it.
5.  Ensure the returned JSON is valid.
6.  Do not add any explanatory text, comments, or markdown formatting. Your response must be **only the raw JSON object**.

For example, if the user says "remove the barbell bench press from day 1", you should find that exercise in the `workouts` array and remove it, then return the whole JSON object.
If the user says "make day 2 a rest day", you should modify the components of the workout for day 2 to reflect a rest day (e.g., empty arrays for components).

Now, generate the updated JSON plan.
"""
    try:
        response = model.generate_content(prompt)
        # Clean the response to get raw JSON
        cleaned_response = response.text.strip().replace('`','').replace('json', '')
        updated_plan_json = json.loads(cleaned_response)
        return {"updated_plan": updated_plan_json}
    except (json.JSONDecodeError, KeyError) as e:
        raise HTTPException(status_code=500, detail=f"AI failed to return valid JSON. Error: {e}")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error calling Gemini API: {e}")


@app.post("/chat", response_model=ChatResponse)
async def chat(request: ChatRequest):
    # This is a simplified chat flow now, mainly for the initial plan generation.
    # The more complex state machine is replaced by a direct call for the 'build-plan' page.
    state = request.state or {"history": []}
    history = state.get("history", [])

    if not history:
         # Initial greeting
        initial_message = "Hi, I am your AI fitness programming assistant. I am going to ask a series of questions to hone your squadâ€™s workout plan to their needs.\n\nWhat test are you preparing for (e.g., ACFT) and what is the date of that test?"
        history.append({"role": "model", "parts": [initial_message]})
        return ChatResponse(
            message=initial_message,
            state={"history": history}
        )

    # Add user's message to history
    history.append({"role": "user", "parts": [request.message]})

    # The get_gemini_response logic is now specific to plan generation
    prompt = f"""The following is a conversation with an AI fitness programming assistant. 
The assistant asks questions to create a personalized workout plan.

Based on the conversation, either ask the next clarifying question, or if you have enough information, 
respond with a JSON object containing the following keys:
- "test_name": string (e.g., "ACFT")
- "test_date": string (YYYY-MM-DD)
- "days_per_week": int (3-5)
- "high_level_focus": 'strength' or 'cardio'
- "strength_focus": 'endurance', 'hypertrophy', 'power', or 'strength' (or null if cardio)
- "muscle_target": list of strings (e.g., ["chest", "back", "legs"])
- "equipment": list of strings (e.g., ["barbell", "dumbbell"])
- "num_soldiers": int

UNTIL THE FINAL MESSAGE, RESPOND IN PLAIN TEXT WITH NO METADATA.

Do not ask for information you already have. Here is the conversation history:
{json.dumps(history, indent=2)}
"""
    try:
        response = model.generate_content(prompt)
        gemini_response = response.text
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error calling Gemini API: {e}")


    # Check if the response is the final JSON
    try:
        # The response might have markdown formatting
        cleaned_response = gemini_response.strip().replace('`','').replace('json', '')
        plan_data_json = json.loads(cleaned_response)

        # If we get here, we have the plan data
        exercise_lib = create_exercise_library()
        week_plan = weekly_plan(plan_data_json, exercise_lib)
        program_text = export_program_to_text(week_plan, plan_data_json.get('strength_focus', 'hypertrophy'))
        plan_data = [asdict(day) for day in week_plan]

        final_message = "I've generated a custom workout plan for your squad based on your requirements."
        history.append({"role": "model", "parts": [final_message]})

        return ChatResponse(
            message=final_message,
            state={"history": history},
            is_complete=True,
            plan=program_text,
            plan_data=plan_data
        )

    except (json.JSONDecodeError, KeyError):
        # The response is another question, so we continue the conversation
        history.append({"role": "model", "parts": [gemini_response]})
        return ChatResponse(
            message=gemini_response,
            state={"history": history}
        )

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
